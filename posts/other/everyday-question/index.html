<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Everyday Question | Isyuanpeng</title>
<meta name="keywords" content="question" />
<meta name="description" content="每日一问
2022-06-21 setter &amp; getter

setter 和 gettter 的实际意义



为什么要有setter &amp; getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写

安全：程序可以选择只读或只写或读写
灵活：如果不仅仅只是读写属性值，可以自由变换
封装：隐藏内部实现细节
健壮：便于维护，扩展



由上一问，为什么public是不安全的呢？

如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。



扩展：Java的四大特性 - 直接粘贴


封装
What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C&#43;&#43; 的 “:” 。
Why: 解决代码复用问题。

多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

2022-06-22 编译&amp;反编译
编译：源码 -&gt; 字节码
反编译：字节码 -&gt; 源码
什么是字节码，采用字节码的好处是什么？
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。">
<meta name="author" content="YuanPeng11">
<link rel="canonical" href="https://isyuanpeng.github.io/posts/other/everyday-question/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css" integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://isyuanpeng.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://isyuanpeng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://isyuanpeng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://isyuanpeng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://isyuanpeng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.140.1">
<link rel="alternate" hreflang="en" href="https://isyuanpeng.github.io/posts/other/everyday-question/" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Everyday Question" />
<meta property="og:description" content="每日一问
2022-06-21 setter &amp; getter

setter 和 gettter 的实际意义



为什么要有setter &amp; getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写

安全：程序可以选择只读或只写或读写
灵活：如果不仅仅只是读写属性值，可以自由变换
封装：隐藏内部实现细节
健壮：便于维护，扩展



由上一问，为什么public是不安全的呢？

如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。



扩展：Java的四大特性 - 直接粘贴


封装
What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C&#43;&#43; 的 “:” 。
Why: 解决代码复用问题。

多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

2022-06-22 编译&amp;反编译
编译：源码 -&gt; 字节码
反编译：字节码 -&gt; 源码
什么是字节码，采用字节码的好处是什么？
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://isyuanpeng.github.io/posts/other/everyday-question/" /><meta property="og:image" content="https://isyuanpeng.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-22T10:18:49&#43;08:00" />
<meta property="article:modified_time" content="2022-06-22T10:18:49&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://isyuanpeng.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Everyday Question"/>
<meta name="twitter:description" content="每日一问
2022-06-21 setter &amp; getter

setter 和 gettter 的实际意义



为什么要有setter &amp; getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写

安全：程序可以选择只读或只写或读写
灵活：如果不仅仅只是读写属性值，可以自由变换
封装：隐藏内部实现细节
健壮：便于维护，扩展



由上一问，为什么public是不安全的呢？

如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。



扩展：Java的四大特性 - 直接粘贴


封装
What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C&#43;&#43; 的 “:” 。
Why: 解决代码复用问题。

多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

2022-06-22 编译&amp;反编译
编译：源码 -&gt; 字节码
反编译：字节码 -&gt; 源码
什么是字节码，采用字节码的好处是什么？
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://isyuanpeng.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Everyday Question",
      "item": "https://isyuanpeng.github.io/posts/other/everyday-question/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Everyday Question",
  "name": "Everyday Question",
  "description": "每日一问 2022-06-21 setter \u0026amp; getter setter 和 gettter 的实际意义 为什么要有setter \u0026amp; getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写\n安全：程序可以选择只读或只写或读写 灵活：如果不仅仅只是读写属性值，可以自由变换 封装：隐藏内部实现细节 健壮：便于维护，扩展 由上一问，为什么public是不安全的呢？\n如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。 扩展：Java的四大特性 - 直接粘贴\n封装\nWhat：隐藏信息，保护数据访问。 How：暴露有限接口和属性，需要编程语言提供访问控制的语法。 Why：提高代码可维护性；降低接口复杂度，提高类的易用性。 抽象\nWhat: 隐藏具体实现，使用者只需关心功能，无需关心实现。 How: 通过接口类或者抽象类实现，特殊语法机制非必须。 Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。 继承\nWhat: 表示 is-a 关系，分为单继承和多继承。 How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。 Why: 解决代码复用问题。 多态\nWhat: 子类替换父类，在运行时调用子类的实现。 How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。 Why: 提高代码扩展性和复用性。 2022-06-22 编译\u0026amp;反编译 编译：源码 -\u0026gt; 字节码 反编译：字节码 -\u0026gt; 源码\n什么是字节码，采用字节码的好处是什么？ 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\n",
  "keywords": [
    "question"
  ],
  "articleBody": "每日一问 2022-06-21 setter \u0026 getter setter 和 gettter 的实际意义 为什么要有setter \u0026 getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写\n安全：程序可以选择只读或只写或读写 灵活：如果不仅仅只是读写属性值，可以自由变换 封装：隐藏内部实现细节 健壮：便于维护，扩展 由上一问，为什么public是不安全的呢？\n如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。 扩展：Java的四大特性 - 直接粘贴\n封装\nWhat：隐藏信息，保护数据访问。 How：暴露有限接口和属性，需要编程语言提供访问控制的语法。 Why：提高代码可维护性；降低接口复杂度，提高类的易用性。 抽象\nWhat: 隐藏具体实现，使用者只需关心功能，无需关心实现。 How: 通过接口类或者抽象类实现，特殊语法机制非必须。 Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。 继承\nWhat: 表示 is-a 关系，分为单继承和多继承。 How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。 Why: 解决代码复用问题。 多态\nWhat: 子类替换父类，在运行时调用子类的实现。 How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。 Why: 提高代码扩展性和复用性。 2022-06-22 编译\u0026反编译 编译：源码 -\u003e 字节码 反编译：字节码 -\u003e 源码\n什么是字节码，采用字节码的好处是什么？ 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\n2022-06-23 为什么String不可变 什么是不可变 一旦对象被创建并初始化后，内部的状态数据就会保持不变\n为什么String不可变 最初的设计就是不可变，设计就是遵循一定的规则，基本约定，体现一致性。 final和immutable无关 如果String可变，那么String就可以在方法之前来回穿梭，最终变成什么无人可知。 安全性：String作为hashmap的key值的时候，如果发生改变，则很难被发现 无线程安全问题 所以声明String为final一劳永逸 2022-06-25 为什么不应该通过类实例访问静态成员 如果使用类的实例来访问静态成员的话，那么IDEA会WARNING，那为什么会有这个WARNING呢？\n查了一下网上的说明，模糊不清的说法是实例会被回收。\n引申问题1 - 静态为什么叫静态？ 静态变量 -\u003e 类变量 是继承类的 所有对象共有的 非静态变量 -\u003e 实例变量 具体对象的具体数据 根据对象的变化而变化 是继承对象的\n引申问题2 - 什么时候可以定义静态变量或者方法？ 所有的类都拥有的共同的属性 -\u003e 静态变量\n方法内部没有使用到非静态数据 -\u003e 静态方法\n引申知识点 静态的特点\n通过类的加载而加载 类一旦被加载进内存，静态的变量和方法就被加载进去了，对象还不存在 静态先于对象存在 被所有的对象共享 可以直接被类名调用，也可以被对象调用 静态使用的注意事项\n静态方法只能访问静态成员，不能访问非静态成员 非静态成员可以访问静态成员，也可以访问非静态成员 静态方法中不能出现this,super等关键字 静态的好处和坏处\n优点：对于所有对象都共有的数据，节省空间；可以不新建对象直接使用； 缺点：静态是通过类存在的，访问存在局限性，只能访问静态数据 2022-06-29 HashMap 数据结构 数组(每个Node叫做bucket) + 链表 + 红黑树\n主体是一个数组，数组由一个个链表组成，链表由一个个Node组成，Node存储具体的key value\n为什么要使用数组+链表的数据结构 解决hash冲突，首先使用hash(key)得出key的hash值，然后通过 (n-1) \u0026 hash 得出index，键值对存在该index所在的数组链表中。\n不同的key可能产生相同的hash值\n如何解决Hash冲突 遇到hash冲突后，会先判断两个key值是否相同，相同说明是同一个key，则覆盖。如果不相同，会将这个Node插入链表的尾部。\n头插法和尾插法 头插法：每次在头部插入，作者认为后面插入的使用的概率会更大，会造成死锁的问题 尾插法：每次在尾部插入，JDK1.8后更新\n为什么要把链表转换为红黑树？ 查找效率 链表：时间复杂度O(n) 红黑树：时间复杂度O(log(n))\n链表较短的时候差距不大，较长的时候可以提升效率\n为什么不直接使用红黑树的数据结构 红黑树的空间复杂度是链表的2倍\n2022-06-30 反射 反射是什么？ 反射可以在运行时检查类、接口、方法和变量等信息，无需知道类的名字，方法名等。还可以在运行时实例化新对象，调用方法以及设置和获取变量值。\n2022-07-04 - 07-05 红黑树 6.29日看了hashmap的原理，那么红黑树到底是什么呢？\n二叉查找树 BST(Binary Search Tree) 任何一个节点的左子树上的点，都必须小于当前节点。 任何一个节点的右子树上的点，都必须大于当前节点。 任何一颗子树，也都满足上面两个条件。\n2-3-4树 4阶的B树，Balance Tree\n所有的叶子节点都拥有相同的深度 叶节点只能是2-节点、3-节点、4-节点 元素使用保持排序顺序，父节点大于左子节点，小于右子节点，如果节点有多个元素，则每个元素必须大于它左边的和它左子树中的元素\n2022-07-07 为什么https协议调用接口需要SSL认证 SSL: Secure Sockets Layer, 安全套接字层，为了解决HTTP协议是明文，避免传输的数据被窃取，篡改，劫持。 TSL: Transport Layer Security, 传输层安全协议。TSL是SSL标准化的产物。 HTTPS: 兼容HTTP，HTTP over TSL，HTTPS = HTTP + TSL 总之，就是为了安全\nJava里面怎么做？ 如果是Resttemplate的话需要跳过,具体代码如下, 在RestTemplateConfig中加入下面代码: 1 2 3 SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(null, (X509Certificate[] chain, String authType) -\u003e true).build(); SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext, (s, sslSession) -\u003e true); CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(csf).setMaxConnPerRoute(1000).setMaxConnTotal(1000).build(); X509Certificate X.509是公钥基础设施（PKI）的标准格式。X.509证书就是基于国际电信联盟（ITU）制定的X.509标准的数字证书。\n2022-07-11 @Controller \u0026 @RestController @ResponseBody 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用此注解此次请求将不再走视图处理器，而是直接将此响应结果写入到输入流中，其效果等同于使用response对象输出指定格式的数据。\n@Controller @Service @Compoent spring在启动时，有一个非常核心的类ConfigurationClassPostProcessor会对类路径下的所以类进行扫描，将符合条件的bean扫描出来添加到beanDefinitionMap集合中，方便接下来的实例化。\n@Controller 如果不使用springMVC时，三者使用其实是没有什么差别的，但如果使用了springMVC，@Controller就被赋予了特殊的含义。\nspring会遍历上面扫描出来的所有bean，过滤出那些添加了注解@Controller的bean，将Controller中所有添加了注解@RequestMapping的方法解析出来封装成RequestMappingInfo存储到RequestMappingHandlerMapping中的mappingRegistry。后续请求到达时，会从mappingRegistry中查找能够处理该请求的方法。\n@RestController @Controller + @ResponseBody\n2022-07-15 net.sf.ezmorph.bean.MorphDynaBean是什么？ net.sf.json就是一个类似于fastjson的一个json解析框架，这个库有点老了，现在应该没有人推荐了，所以其实今天这个问题就没必要记录了。但是还是看一下这个问题。\n2022-07-27 2022-07-28 依赖的版本不一致 一般都是因为自定义版本导致的，而有些依赖会使用spring中写好的版本，所以一般这种情况就更改spring定制的版本号即可，更改就是重新写个全局版本号，会覆盖掉之前的。\n2022-07-29 设计模式六大基本原则 单一职责原则 Single Responsibility Principle There should never be more than one reason for a class to change。应该有且仅有一个原因引起类的变更。\n意思也很明显，一个类应该有且只有一个引起它变化的原因。\n实际案例: 手机Class V1：MobileClass, 包含了所有功能，charge(), ringUp(), GPU(), CPU(), RAM(), ROM() V2: BasicProperty, GPU(), CPU(), RAM(), ROM(); BasicFunction, charge(), ringUp() V3: BasicProperty, GPU(), CPU(), RAM(), ROM(); ExtendProperty(), Pixel(); BasicFunction, charge(), ringUp(); ExtendFunction, playGame();\n没有最好的设计，只有最适合的设计。\n2022-07-30 设计模式六大基本原则 里氏替换原则 Liskov Substitution Principle 子类对象能够替换父类对象，而程序逻辑不变。\n有两种情况，使用共享方法或者是为了多态。\n共享方法：子类继承父类为了方法重用，则子类不应该去改变父类中的共享方法。子类和父类都可以实例化，如果子类复写父类的共享类，则违反了LSP，子类对象不能够替换父类对象，逻辑有可能不一致。 多态：如果继承为了多态，则应该将父类方法设为抽象类或者接口，这样子类重新定义父类的方法，父类不能实例化，替换的时候不会造成逻辑上的不一致。 如何符合LSP：尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。\n2022-07-31 多态 2023-04-10 三次握手 重启每日一问的问题，同步更新微信\n首先先明确一下三次握手的流程：\nshake hands1: client send [SYN, SEQ=X] -\u003e server\nshake hands2: server send [SYN, ACK=X+1, SEQ=Y] -\u003e client\nshake hands3: client send [ACK=Y+1, SEQ=Z] -\u003e server\n接下来开始使用wireshark进行抓包，查看抓包中的交互信息，下面以www.baidu.com为目标进行抓包。通过ping查看www.baidu.com的真正ip为110.242.68.4，通过wireshark的过滤条件src host 110.242.68.4 or dst host 110.242.68.4 来过滤数据包。\nShake hands 1 可以看到前三个请求都为TCP的请求，就是我们所说的握手过程，只有在握手之后才能进行真正的http的请求。\n可以看到第一次握手中客户端源端口61539向服务器目标端口443端口进行SYN的请求，SYN=1，ACK=0表示连接请求报文段。\nShake hands 2 在第二次握手的时候可以看到SYN=1，ACK=1表示服务器同意客户端的连接请求。我们也可以看到seq+1。\nShake hands 3 第三次握手，客户端发送ACK=1给服务端，此时TCP连接成功，开始发送和接收数据。\n2023-04-11 四次挥手 上面的三次握手学完之后，相信对整个TCP的连接和wireshark的使用有了基本的了解。下面简单看一下四次挥手的过程即可。\nfour waves 1: client send [FIN, ACK, Seq=X, ACK=Y] to server four waves 2: server send [ACK, Seq=Y, Ack=X+1] to client four waves 3: server send [FIN, ACK, Seq=Z, Ack=X+1] to client four waves 4: client send [ACK, Seq=X+1, Ack=Z+1] to server\n2023-04-13 IOC - Inversion of Control 资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。\n2023-04-14 Nginx 配置项 tcp_nodelay Nagle Algorithm: John Nagle的名字来命名的，John Nagle在1984年首次用这个算法来尝试解决福特汽车公司的网络拥塞问题（RFC 896）。如果每次发送一个1 byte的数据包，实际大小需要40(20ip header bytes + 20 tcp header bytes) + 1 byte = 41bytes，Nagle算法解决了该问题，如果包的大小满足MSS，那么可以立即发送，否则放入缓冲区，等到已经发送的包被确认了之后继续发送。\nDelayedAcknowledgment: 如果需要单独确认每个包的大小的话，那么整个网络当中将充斥着无数的ACK，降低网络性能，DelayedAcknowledgment规定: 不再针对单个包发送ACK确认，而是一次确认两个包，或者在发送相应数据的时候捎带这发送ACK，又或者出发超时时间后再发送ACK。\n上述的两个解决网络性能问题的方法如果在一起使用，会触发延迟问题，如果TCP client端启用了Nagle Algorithm, Server启用 Delayed ACK，并且发送的数据包比较小，Client端需要等待Server端对上一个packet的Ack才能发送当前Packet，Server延迟发送Ack，那整个通信将会被延迟。\n数据量小，交互多的情况需禁用Nagle算法和Delay，TCP_NODELAY: on 数据量大，交互少需要开启，这种情况典型的应用是文件服务器 仅长连接使用 tcp_nopush tcp_nopush就是开启linux中的TCP_CORK(塞子), 类似于在发送数据管道处插一个cork，阻塞所有数据，直到取消cork，全部发送阻塞数据。\ntcp_nopush和sendfile一起使用。\nsendfile 正常网络文件传输过程:\nfile -\u003e 硬盘 -\u003e kernel buffer -\u003e user buffer -\u003e kernel socket buffer -\u003e 协议栈\nsenfile网络文件传输过程:\nfile -\u003e 硬盘 -\u003e kernel buffer(快速拷贝到kernel socket buffer) -\u003e 协议栈\n性能提升\nhttps://www.cnblogs.com/wajika/p/6573014.html\nlua_shared_dict access 10m ",
  "wordCount" : "495",
  "inLanguage": "en",
  "datePublished": "2022-06-22T10:18:49+08:00",
  "dateModified": "2022-06-22T10:18:49+08:00",
  "author":[{
    "@type": "Person",
    "name": "YuanPeng11"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://isyuanpeng.github.io/posts/other/everyday-question/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Isyuanpeng",
    "logo": {
      "@type": "ImageObject",
      "url": "https://isyuanpeng.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://isyuanpeng.github.io/" accesskey="h" title="Isyuanpeng (Alt + H)">Isyuanpeng</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://isyuanpeng.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://isyuanpeng.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://isyuanpeng.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Everyday Question
    </h1>
    <div class="post-meta">&lt;span title=&#39;2022-06-22 10:18:49 &#43;0800 &#43;0800&#39;&gt;June 22, 2022&lt;/span&gt;&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;YuanPeng11

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e6%af%8f%e6%97%a5%e4%b8%80%e9%97%ae" aria-label="每日一问">每日一问</a><ul>
                            
                    <li>
                        <a href="#2022-06-21-setter--getter" aria-label="2022-06-21 setter &amp; getter">2022-06-21 setter &amp; getter</a></li>
                    <li>
                        <a href="#2022-06-22-%e7%bc%96%e8%af%91%e5%8f%8d%e7%bc%96%e8%af%91" aria-label="2022-06-22 编译&amp;反编译">2022-06-22 编译&amp;反编译</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e8%8a%82%e7%a0%81%e9%87%87%e7%94%a8%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e5%a5%bd%e5%a4%84%e6%98%af%e4%bb%80%e4%b9%88" aria-label="什么是字节码，采用字节码的好处是什么？">什么是字节码，采用字节码的好处是什么？</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-06-23-%e4%b8%ba%e4%bb%80%e4%b9%88string%e4%b8%8d%e5%8f%af%e5%8f%98" aria-label="2022-06-23 为什么String不可变">2022-06-23 为什么String不可变</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8d%e5%8f%af%e5%8f%98" aria-label="什么是不可变">什么是不可变</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88string%e4%b8%8d%e5%8f%af%e5%8f%98" aria-label="为什么String不可变">为什么String不可变</a></li>
                    <li>
                        <a href="#2022-06-25-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%ba%94%e8%af%a5%e9%80%9a%e8%bf%87%e7%b1%bb%e5%ae%9e%e4%be%8b%e8%ae%bf%e9%97%ae%e9%9d%99%e6%80%81%e6%88%90%e5%91%98" aria-label="2022-06-25 为什么不应该通过类实例访问静态成员">2022-06-25 为什么不应该通过类实例访问静态成员</a><ul>
                            
                    <li>
                        <a href="#%e5%bc%95%e7%94%b3%e9%97%ae%e9%a2%981---%e9%9d%99%e6%80%81%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%ab%e9%9d%99%e6%80%81" aria-label="引申问题1 - 静态为什么叫静态？">引申问题1 - 静态为什么叫静态？</a></li>
                    <li>
                        <a href="#%e5%bc%95%e7%94%b3%e9%97%ae%e9%a2%982---%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%8f%af%e4%bb%a5%e5%ae%9a%e4%b9%89%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e6%88%96%e8%80%85%e6%96%b9%e6%b3%95" aria-label="引申问题2 - 什么时候可以定义静态变量或者方法？">引申问题2 - 什么时候可以定义静态变量或者方法？</a></li>
                    <li>
                        <a href="#%e5%bc%95%e7%94%b3%e7%9f%a5%e8%af%86%e7%82%b9" aria-label="引申知识点">引申知识点</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-06-29-hashmap" aria-label="2022-06-29 HashMap">2022-06-29 HashMap</a><ul>
                            
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="数据结构">数据结构</a></li>
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="为什么要使用数组&#43;链表的数据结构">为什么要使用数组+链表的数据结构</a></li>
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%8a%8a%e9%93%be%e8%a1%a8%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%ba%a2%e9%bb%91%e6%a0%91" aria-label="为什么要把链表转换为红黑树？">为什么要把链表转换为红黑树？</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-06-30-%e5%8f%8d%e5%b0%84" aria-label="2022-06-30 反射">2022-06-30 反射</a><ul>
                            
                    <li>
                        <a href="#%e5%8f%8d%e5%b0%84%e6%98%af%e4%bb%80%e4%b9%88" aria-label="反射是什么？">反射是什么？</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-04---07-05-%e7%ba%a2%e9%bb%91%e6%a0%91" aria-label="2022-07-04 - 07-05 红黑树">2022-07-04 - 07-05 红黑树</a><ul>
                            
                    <li>
                        <a href="#%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91-bstbinary-search-tree" aria-label="二叉查找树 BST(Binary Search Tree)">二叉查找树 BST(Binary Search Tree)</a></li>
                    <li>
                        <a href="#2-3-4%e6%a0%91" aria-label="2-3-4树">2-3-4树</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-07" aria-label="2022-07-07">2022-07-07</a><ul>
                            
                    <li>
                        <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88https%e5%8d%8f%e8%ae%ae%e8%b0%83%e7%94%a8%e6%8e%a5%e5%8f%a3%e9%9c%80%e8%a6%81ssl%e8%ae%a4%e8%af%81" aria-label="为什么https协议调用接口需要SSL认证">为什么https协议调用接口需要SSL认证</a></li>
                    <li>
                        <a href="#java%e9%87%8c%e9%9d%a2%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="Java里面怎么做？">Java里面怎么做？</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-11" aria-label="2022-07-11">2022-07-11</a><ul>
                            
                    <li>
                        <a href="#controller--restcontroller" aria-label="@Controller &amp; @RestController">@Controller &amp; @RestController</a><ul>
                            
                    <li>
                        <a href="#responsebody" aria-label="@ResponseBody">@ResponseBody</a></li>
                    <li>
                        <a href="#controller-service-compoent" aria-label="@Controller @Service @Compoent">@Controller @Service @Compoent</a></li>
                    <li>
                        <a href="#controller" aria-label="@Controller">@Controller</a></li>
                    <li>
                        <a href="#restcontroller" aria-label="@RestController">@RestController</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-15" aria-label="2022-07-15">2022-07-15</a><ul>
                            
                    <li>
                        <a href="#netsfezmorphbeanmorphdynabean%e6%98%af%e4%bb%80%e4%b9%88" aria-label="net.sf.ezmorph.bean.MorphDynaBean是什么？">net.sf.ezmorph.bean.MorphDynaBean是什么？</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-27" aria-label="2022-07-27">2022-07-27</a></li>
                    <li>
                        <a href="#2022-07-28" aria-label="2022-07-28">2022-07-28</a><ul>
                            
                    <li>
                        <a href="#%e4%be%9d%e8%b5%96%e7%9a%84%e7%89%88%e6%9c%ac%e4%b8%8d%e4%b8%80%e8%87%b4" aria-label="依赖的版本不一致">依赖的版本不一致</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-29-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%85%ad%e5%a4%a7%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99" aria-label="2022-07-29 设计模式六大基本原则">2022-07-29 设计模式六大基本原则</a><ul>
                            
                    <li>
                        <a href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99-single-responsibility-principle" aria-label="单一职责原则 Single Responsibility Principle">单一职责原则 Single Responsibility Principle</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-30-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%85%ad%e5%a4%a7%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99" aria-label="2022-07-30 设计模式六大基本原则">2022-07-30 设计模式六大基本原则</a><ul>
                            
                    <li>
                        <a href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99-liskov-substitution-principle" aria-label="里氏替换原则 Liskov Substitution Principle">里氏替换原则 Liskov Substitution Principle</a></li></ul>
                    </li>
                    <li>
                        <a href="#2022-07-31" aria-label="2022-07-31">2022-07-31</a><ul>
                            
                    <li>
                        <a href="#%e5%a4%9a%e6%80%81" aria-label="多态">多态</a></li></ul>
                    </li>
                    <li>
                        <a href="#2023-04-10-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="2023-04-10 三次握手">2023-04-10 三次握手</a><ul>
                            
                    <li>
                        <a href="#shake-hands-1" aria-label="Shake hands 1">Shake hands 1</a></li>
                    <li>
                        <a href="#shake-hands-2" aria-label="Shake hands 2">Shake hands 2</a></li>
                    <li>
                        <a href="#shake-hands-3" aria-label="Shake hands 3">Shake hands 3</a></li></ul>
                    </li>
                    <li>
                        <a href="#2023-04-11-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="2023-04-11 四次挥手">2023-04-11 四次挥手</a></li>
                    <li>
                        <a href="#2023-04-13-ioc---inversion-of-control" aria-label="2023-04-13 IOC - Inversion of Control">2023-04-13 IOC - Inversion of Control</a></li>
                    <li>
                        <a href="#2023-04-14-nginx-%e9%85%8d%e7%bd%ae%e9%a1%b9" aria-label="2023-04-14 Nginx 配置项">2023-04-14 Nginx 配置项</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h2 id="每日一问">每日一问<a hidden class="anchor" aria-hidden="true" href="#每日一问">#</a></h2>
<h3 id="2022-06-21-setter--getter">2022-06-21 setter &amp; getter<a hidden class="anchor" aria-hidden="true" href="#2022-06-21-setter--getter">#</a></h3>
<ol>
<li>setter 和 gettter 的实际意义</li>
</ol>
<ul>
<li>
<p>为什么要有setter &amp; getter, public dot直接使用不是更方便快捷吗？ 而且setter和getter最终的效果也是读写</p>
<ul>
<li>安全：程序可以选择只读或只写或读写</li>
<li>灵活：如果不仅仅只是读写属性值，可以自由变换</li>
<li>封装：隐藏内部实现细节</li>
<li>健壮：便于维护，扩展</li>
</ul>
</li>
<li>
<p>由上一问，为什么public是不安全的呢？</p>
<ul>
<li>如果写sdk的话，那么有些数据是不想对外修改的，这时候public的作用就体现出来了。如果只是业务代码则，权限体现的不太大。</li>
</ul>
</li>
<li>
<p>扩展：Java的四大特性 - 直接粘贴</p>
</li>
</ul>
<p>封装</p>
<pre><code>What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。
</code></pre>
<p>抽象</p>
<pre><code>What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。
</code></pre>
<p>继承</p>
<pre><code>What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
Why: 解决代码复用问题。
</code></pre>
<p>多态</p>
<pre><code>What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。
</code></pre>
<h3 id="2022-06-22-编译反编译">2022-06-22 编译&amp;反编译<a hidden class="anchor" aria-hidden="true" href="#2022-06-22-编译反编译">#</a></h3>
<p>编译：源码 -&gt; 字节码
反编译：字节码 -&gt; 源码</p>
<h4 id="什么是字节码采用字节码的好处是什么">什么是字节码，采用字节码的好处是什么？<a hidden class="anchor" aria-hidden="true" href="#什么是字节码采用字节码的好处是什么">#</a></h4>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h3 id="2022-06-23-为什么string不可变">2022-06-23 为什么String不可变<a hidden class="anchor" aria-hidden="true" href="#2022-06-23-为什么string不可变">#</a></h3>
<h4 id="什么是不可变">什么是不可变<a hidden class="anchor" aria-hidden="true" href="#什么是不可变">#</a></h4>
<p>一旦对象被创建并初始化后，内部的状态数据就会保持不变</p>
<h3 id="为什么string不可变">为什么String不可变<a hidden class="anchor" aria-hidden="true" href="#为什么string不可变">#</a></h3>
<ol>
<li>最初的设计就是不可变，设计就是遵循一定的规则，基本约定，体现一致性。</li>
<li>final和immutable无关</li>
<li>如果String可变，那么String就可以在方法之前来回穿梭，最终变成什么无人可知。</li>
<li>安全性：String作为hashmap的key值的时候，如果发生改变，则很难被发现</li>
<li>无线程安全问题</li>
<li>所以声明String为final一劳永逸</li>
</ol>
<h3 id="2022-06-25-为什么不应该通过类实例访问静态成员">2022-06-25 为什么不应该通过类实例访问静态成员<a hidden class="anchor" aria-hidden="true" href="#2022-06-25-为什么不应该通过类实例访问静态成员">#</a></h3>
<p>如果使用类的实例来访问静态成员的话，那么IDEA会WARNING，那为什么会有这个WARNING呢？</p>
<p>查了一下网上的说明，模糊不清的说法是实例会被回收。</p>
<h4 id="引申问题1---静态为什么叫静态">引申问题1 - 静态为什么叫静态？<a hidden class="anchor" aria-hidden="true" href="#引申问题1---静态为什么叫静态">#</a></h4>
<p>静态变量 -&gt; 类变量 是继承类的 所有对象共有的
非静态变量 -&gt; 实例变量 具体对象的具体数据 根据对象的变化而变化 是继承对象的</p>
<h4 id="引申问题2---什么时候可以定义静态变量或者方法">引申问题2 - 什么时候可以定义静态变量或者方法？<a hidden class="anchor" aria-hidden="true" href="#引申问题2---什么时候可以定义静态变量或者方法">#</a></h4>
<p>所有的类都拥有的共同的属性 -&gt; 静态变量</p>
<p>方法内部没有使用到非静态数据 -&gt; 静态方法</p>
<h4 id="引申知识点">引申知识点<a hidden class="anchor" aria-hidden="true" href="#引申知识点">#</a></h4>
<ol>
<li>
<p>静态的特点</p>
<ul>
<li>通过类的加载而加载 类一旦被加载进内存，静态的变量和方法就被加载进去了，对象还不存在</li>
<li>静态先于对象存在</li>
<li>被所有的对象共享</li>
<li>可以直接被类名调用，也可以被对象调用</li>
</ul>
</li>
<li>
<p>静态使用的注意事项</p>
<ul>
<li>静态方法只能访问静态成员，不能访问非静态成员</li>
<li>非静态成员可以访问静态成员，也可以访问非静态成员</li>
<li>静态方法中不能出现this,super等关键字</li>
</ul>
</li>
<li>
<p>静态的好处和坏处</p>
<ul>
<li>优点：对于所有对象都共有的数据，节省空间；可以不新建对象直接使用；</li>
<li>缺点：静态是通过类存在的，访问存在局限性，只能访问静态数据</li>
</ul>
</li>
</ol>
<h3 id="2022-06-29-hashmap">2022-06-29 HashMap<a hidden class="anchor" aria-hidden="true" href="#2022-06-29-hashmap">#</a></h3>
<h4 id="数据结构">数据结构<a hidden class="anchor" aria-hidden="true" href="#数据结构">#</a></h4>
<p>数组(每个Node叫做bucket) + 链表 + 红黑树</p>
<p>主体是一个数组，数组由一个个链表组成，链表由一个个Node组成，Node存储具体的key value</p>
<h4 id="为什么要使用数组链表的数据结构">为什么要使用数组+链表的数据结构<a hidden class="anchor" aria-hidden="true" href="#为什么要使用数组链表的数据结构">#</a></h4>
<p>解决hash冲突，首先使用hash(key)得出key的hash值，然后通过 (n-1) &amp; hash 得出index，键值对存在该index所在的数组链表中。</p>
<p>不同的key可能产生相同的hash值</p>
<ol>
<li>如何解决Hash冲突</li>
</ol>
<p>遇到hash冲突后，会先判断两个key值是否相同，相同说明是同一个key，则覆盖。如果不相同，会将这个Node插入链表的尾部。</p>
<ol start="2">
<li>头插法和尾插法</li>
</ol>
<p>头插法：每次在头部插入，作者认为后面插入的使用的概率会更大，会造成死锁的问题
尾插法：每次在尾部插入，JDK1.8后更新</p>
<h4 id="为什么要把链表转换为红黑树">为什么要把链表转换为红黑树？<a hidden class="anchor" aria-hidden="true" href="#为什么要把链表转换为红黑树">#</a></h4>
<ol>
<li>查找效率</li>
</ol>
<p>链表：时间复杂度O(n)
红黑树：时间复杂度O(log(n))</p>
<p>链表较短的时候差距不大，较长的时候可以提升效率</p>
<ol start="2">
<li>为什么不直接使用红黑树的数据结构</li>
</ol>
<p>红黑树的空间复杂度是链表的2倍</p>
<h3 id="2022-06-30-反射">2022-06-30 反射<a hidden class="anchor" aria-hidden="true" href="#2022-06-30-反射">#</a></h3>
<h4 id="反射是什么">反射是什么？<a hidden class="anchor" aria-hidden="true" href="#反射是什么">#</a></h4>
<p>反射可以在运行时检查类、接口、方法和变量等信息，无需知道类的名字，方法名等。还可以在运行时实例化新对象，调用方法以及设置和获取变量值。</p>
<h3 id="2022-07-04---07-05-红黑树">2022-07-04 - 07-05 红黑树<a hidden class="anchor" aria-hidden="true" href="#2022-07-04---07-05-红黑树">#</a></h3>
<p>6.29日看了hashmap的原理，那么红黑树到底是什么呢？</p>
<h4 id="二叉查找树-bstbinary-search-tree">二叉查找树 BST(Binary Search Tree)<a hidden class="anchor" aria-hidden="true" href="#二叉查找树-bstbinary-search-tree">#</a></h4>
<p>任何一个节点的左子树上的点，都必须小于当前节点。
任何一个节点的右子树上的点，都必须大于当前节点。
任何一颗子树，也都满足上面两个条件。</p>
<h4 id="2-3-4树">2-3-4树<a hidden class="anchor" aria-hidden="true" href="#2-3-4树">#</a></h4>
<p>4阶的B树，Balance Tree</p>
<p>所有的叶子节点都拥有相同的深度
叶节点只能是2-节点、3-节点、4-节点
元素使用保持排序顺序，父节点大于左子节点，小于右子节点，如果节点有多个元素，则每个元素必须大于它左边的和它左子树中的元素</p>
<h2 id="2022-07-07">2022-07-07<a hidden class="anchor" aria-hidden="true" href="#2022-07-07">#</a></h2>
<h3 id="为什么https协议调用接口需要ssl认证">为什么https协议调用接口需要SSL认证<a hidden class="anchor" aria-hidden="true" href="#为什么https协议调用接口需要ssl认证">#</a></h3>
<ol>
<li>SSL: Secure Sockets Layer, 安全套接字层，为了解决HTTP协议是明文，避免传输的数据被窃取，篡改，劫持。</li>
<li>TSL: Transport Layer Security, 传输层安全协议。TSL是SSL标准化的产物。</li>
<li>HTTPS: 兼容HTTP，HTTP over TSL，HTTPS = HTTP + TSL</li>
</ol>
<p>总之，就是为了安全</p>
<h3 id="java里面怎么做">Java里面怎么做？<a hidden class="anchor" aria-hidden="true" href="#java里面怎么做">#</a></h3>
<ol>
<li>如果是Resttemplate的话需要跳过,具体代码如下, 在RestTemplateConfig中加入下面代码:</li>
</ol>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>SSLContext sslContext <span style="color:#f92672">=</span> SSLContexts<span style="color:#f92672">.</span>custom()<span style="color:#f92672">.</span>loadTrustMaterial(null, (X509Certificate[] chain, <span style="color:#a6e22e">String</span> authType) <span style="color:#f92672">-&gt;</span> true)<span style="color:#f92672">.</span>build();
</span></span><span style="display:flex;"><span>SSLConnectionSocketFactory csf <span style="color:#f92672">=</span> new SSLConnectionSocketFactory(sslContext, (s, sslSession) <span style="color:#f92672">-&gt;</span> true);
</span></span><span style="display:flex;"><span>CloseableHttpClient httpClient <span style="color:#f92672">=</span> HttpClients<span style="color:#f92672">.</span>custom()<span style="color:#f92672">.</span>setSSLSocketFactory(csf)<span style="color:#f92672">.</span>setMaxConnPerRoute(<span style="color:#ae81ff">1000</span>)<span style="color:#f92672">.</span>setMaxConnTotal(<span style="color:#ae81ff">1000</span>)<span style="color:#f92672">.</span>build();
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>X509Certificate</li>
</ol>
<p>X.509是公钥基础设施（PKI）的标准格式。X.509证书就是基于国际电信联盟（ITU）制定的X.509标准的数字证书。</p>
<h2 id="2022-07-11">2022-07-11<a hidden class="anchor" aria-hidden="true" href="#2022-07-11">#</a></h2>
<h3 id="controller--restcontroller">@Controller &amp; @RestController<a hidden class="anchor" aria-hidden="true" href="#controller--restcontroller">#</a></h3>
<h4 id="responsebody">@ResponseBody<a hidden class="anchor" aria-hidden="true" href="#responsebody">#</a></h4>
<p>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用此注解此次请求将不再走视图处理器，而是直接将此响应结果写入到输入流中，其效果等同于使用response对象输出指定格式的数据。</p>
<h4 id="controller-service-compoent">@Controller @Service @Compoent<a hidden class="anchor" aria-hidden="true" href="#controller-service-compoent">#</a></h4>
<p>spring在启动时，有一个非常核心的类ConfigurationClassPostProcessor会对类路径下的所以类进行扫描，将符合条件的bean扫描出来添加到beanDefinitionMap集合中，方便接下来的实例化。</p>
<h4 id="controller">@Controller<a hidden class="anchor" aria-hidden="true" href="#controller">#</a></h4>
<p>如果不使用springMVC时，三者使用其实是没有什么差别的，但如果使用了springMVC，@Controller就被赋予了特殊的含义。</p>
<p>spring会遍历上面扫描出来的所有bean，过滤出那些添加了注解@Controller的bean，将Controller中所有添加了注解@RequestMapping的方法解析出来封装成RequestMappingInfo存储到RequestMappingHandlerMapping中的mappingRegistry。后续请求到达时，会从mappingRegistry中查找能够处理该请求的方法。</p>
<h4 id="restcontroller">@RestController<a hidden class="anchor" aria-hidden="true" href="#restcontroller">#</a></h4>
<p>@Controller + @ResponseBody</p>
<h2 id="2022-07-15">2022-07-15<a hidden class="anchor" aria-hidden="true" href="#2022-07-15">#</a></h2>
<h3 id="netsfezmorphbeanmorphdynabean是什么">net.sf.ezmorph.bean.MorphDynaBean是什么？<a hidden class="anchor" aria-hidden="true" href="#netsfezmorphbeanmorphdynabean是什么">#</a></h3>
<p>net.sf.json就是一个类似于fastjson的一个json解析框架，这个库有点老了，现在应该没有人推荐了，所以其实今天这个问题就没必要记录了。但是还是看一下这个问题。</p>
<h2 id="2022-07-27">2022-07-27<a hidden class="anchor" aria-hidden="true" href="#2022-07-27">#</a></h2>
<h2 id="2022-07-28">2022-07-28<a hidden class="anchor" aria-hidden="true" href="#2022-07-28">#</a></h2>
<h3 id="依赖的版本不一致">依赖的版本不一致<a hidden class="anchor" aria-hidden="true" href="#依赖的版本不一致">#</a></h3>
<p>一般都是因为自定义版本导致的，而有些依赖会使用spring中写好的版本，所以一般这种情况就更改spring定制的版本号即可，更改就是重新写个全局版本号，会覆盖掉之前的。</p>
<h2 id="2022-07-29-设计模式六大基本原则">2022-07-29 设计模式六大基本原则<a hidden class="anchor" aria-hidden="true" href="#2022-07-29-设计模式六大基本原则">#</a></h2>
<h3 id="单一职责原则-single-responsibility-principle">单一职责原则 Single Responsibility Principle<a hidden class="anchor" aria-hidden="true" href="#单一职责原则-single-responsibility-principle">#</a></h3>
<p>There should never be more than one reason for a class to change。应该有且仅有一个原因引起类的变更。</p>
<p>意思也很明显，一个类应该有且只有一个引起它变化的原因。</p>
<p>实际案例: 手机Class
V1：MobileClass, 包含了所有功能，charge(), ringUp(), GPU(), CPU(), RAM(), ROM()
V2: BasicProperty,  GPU(), CPU(), RAM(), ROM(); BasicFunction, charge(), ringUp()
V3: BasicProperty, GPU(), CPU(), RAM(), ROM(); ExtendProperty(), Pixel(); BasicFunction, charge(), ringUp(); ExtendFunction, playGame();</p>
<p>没有最好的设计，只有最适合的设计。</p>
<h2 id="2022-07-30-设计模式六大基本原则">2022-07-30 设计模式六大基本原则<a hidden class="anchor" aria-hidden="true" href="#2022-07-30-设计模式六大基本原则">#</a></h2>
<h3 id="里氏替换原则-liskov-substitution-principle">里氏替换原则 Liskov Substitution Principle<a hidden class="anchor" aria-hidden="true" href="#里氏替换原则-liskov-substitution-principle">#</a></h3>
<p>子类对象能够替换父类对象，而程序逻辑不变。</p>
<p>有两种情况，使用共享方法或者是为了多态。</p>
<ol>
<li>共享方法：子类继承父类为了方法重用，则子类不应该去改变父类中的共享方法。子类和父类都可以实例化，如果子类复写父类的共享类，则违反了LSP，子类对象不能够替换父类对象，逻辑有可能不一致。</li>
<li>多态：如果继承为了多态，则应该将父类方法设为抽象类或者接口，这样子类重新定义父类的方法，父类不能实例化，替换的时候不会造成逻辑上的不一致。</li>
</ol>
<p>如何符合LSP：尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</p>
<h2 id="2022-07-31">2022-07-31<a hidden class="anchor" aria-hidden="true" href="#2022-07-31">#</a></h2>
<h3 id="多态">多态<a hidden class="anchor" aria-hidden="true" href="#多态">#</a></h3>
<h2 id="2023-04-10-三次握手">2023-04-10 三次握手<a hidden class="anchor" aria-hidden="true" href="#2023-04-10-三次握手">#</a></h2>
<p>重启每日一问的问题，同步更新微信</p>
<p>首先先明确一下三次握手的流程：</p>
<hr>
<p>shake hands1: client send [SYN, SEQ=X] -&gt; server<br>
shake hands2: server send [SYN, ACK=X+1, SEQ=Y] -&gt; client<br>
shake hands3: client send [ACK=Y+1, SEQ=Z] -&gt; server</p>
<hr>
<p>接下来开始使用wireshark进行抓包，查看抓包中的交互信息，下面以www.baidu.com为目标进行抓包。通过ping查看www.baidu.com的真正ip为110.242.68.4，通过wireshark的过滤条件<em>src host 110.242.68.4 or dst host 110.242.68.4</em> 来过滤数据包。</p>
<p><img loading="lazy" src="https://blog-vx.oss-cn-beijing.aliyuncs.com/three_hand_1.png" alt="three_hands_all"  />
</p>
<h3 id="shake-hands-1">Shake hands 1<a hidden class="anchor" aria-hidden="true" href="#shake-hands-1">#</a></h3>
<p>可以看到前三个请求都为TCP的请求，就是我们所说的握手过程，只有在握手之后才能进行真正的http的请求。</p>
<p><img loading="lazy" src="https://blog-vx.oss-cn-beijing.aliyuncs.com/20230410184353.png" alt="three_hands_1"  />
</p>
<p>可以看到第一次握手中客户端源端口61539向服务器目标端口443端口进行SYN的请求，SYN=1，ACK=0表示连接请求报文段。</p>
<h3 id="shake-hands-2">Shake hands 2<a hidden class="anchor" aria-hidden="true" href="#shake-hands-2">#</a></h3>
<p>在第二次握手的时候可以看到SYN=1，ACK=1表示服务器同意客户端的连接请求。我们也可以看到seq+1。</p>
<p><img loading="lazy" src="https://blog-vx.oss-cn-beijing.aliyuncs.com/20230410185518.png" alt="three_hands_3"  />
</p>
<h3 id="shake-hands-3">Shake hands 3<a hidden class="anchor" aria-hidden="true" href="#shake-hands-3">#</a></h3>
<p>第三次握手，客户端发送ACK=1给服务端，此时TCP连接成功，开始发送和接收数据。</p>
<h2 id="2023-04-11-四次挥手">2023-04-11 四次挥手<a hidden class="anchor" aria-hidden="true" href="#2023-04-11-四次挥手">#</a></h2>
<p>上面的三次握手学完之后，相信对整个TCP的连接和wireshark的使用有了基本的了解。下面简单看一下四次挥手的过程即可。</p>
<hr>
<p>four waves 1: client send [FIN, ACK, Seq=X, ACK=Y] to server <br>
four waves 2: server send [ACK, Seq=Y, Ack=X+1] to client
four waves 3: server send [FIN, ACK, Seq=Z, Ack=X+1] to client
four waves 4: client send [ACK, Seq=X+1, Ack=Z+1] to server</p>
<hr>
<h2 id="2023-04-13-ioc---inversion-of-control">2023-04-13 IOC - Inversion of Control<a hidden class="anchor" aria-hidden="true" href="#2023-04-13-ioc---inversion-of-control">#</a></h2>
<blockquote>
<p>资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
</blockquote>
<h2 id="2023-04-14-nginx-配置项">2023-04-14 Nginx 配置项<a hidden class="anchor" aria-hidden="true" href="#2023-04-14-nginx-配置项">#</a></h2>
<ol>
<li>tcp_nodelay</li>
</ol>
<blockquote>
<p>Nagle Algorithm: John Nagle的名字来命名的，John Nagle在1984年首次用这个算法来尝试解决福特汽车公司的网络拥塞问题（RFC 896）。如果每次发送一个1 byte的数据包，实际大小需要40(20ip header bytes + 20 tcp header bytes) + 1 byte = 41bytes，Nagle算法解决了该问题，如果包的大小满足MSS，那么可以立即发送，否则放入缓冲区，等到已经发送的包被确认了之后继续发送。</p>
</blockquote>
<blockquote>
<p>DelayedAcknowledgment: 如果需要单独确认每个包的大小的话，那么整个网络当中将充斥着无数的ACK，降低网络性能，DelayedAcknowledgment规定: 不再针对单个包发送ACK确认，而是一次确认两个包，或者在发送相应数据的时候捎带这发送ACK，又或者出发超时时间后再发送ACK。</p>
</blockquote>
<blockquote>
<p>上述的两个解决网络性能问题的方法如果在一起使用，会触发延迟问题，如果TCP client端启用了Nagle Algorithm, Server启用 Delayed ACK，并且发送的数据包比较小，Client端需要等待Server端对上一个packet的Ack才能发送当前Packet，Server延迟发送Ack，那整个通信将会被延迟。</p>
</blockquote>
<ul>
<li>数据量小，交互多的情况需禁用Nagle算法和Delay，TCP_NODELAY: on</li>
<li>数据量大，交互少需要开启，这种情况典型的应用是文件服务器</li>
<li>仅长连接使用</li>
</ul>
<ol start="2">
<li>tcp_nopush</li>
</ol>
<p>tcp_nopush就是开启linux中的TCP_CORK(塞子), 类似于在发送数据管道处插一个cork，阻塞所有数据，直到取消cork，全部发送阻塞数据。</p>
<p>tcp_nopush和sendfile一起使用。</p>
<ol start="3">
<li>sendfile</li>
</ol>
<p>正常网络文件传输过程:</p>
<p>file -&gt; 硬盘 -&gt; kernel buffer -&gt; user buffer -&gt; kernel socket buffer -&gt; 协议栈</p>
<p>senfile网络文件传输过程:</p>
<p>file -&gt; 硬盘 -&gt; kernel buffer(快速拷贝到kernel socket buffer) -&gt; 协议栈</p>
<p>性能提升</p>
<blockquote>
<p><a href="https://www.cnblogs.com/wajika/p/6573014.html">https://www.cnblogs.com/wajika/p/6573014.html</a></p>
</blockquote>
<ol start="4">
<li>lua_shared_dict access 10m</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://isyuanpeng.github.io/tags/question/">Question</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://isyuanpeng.github.io/posts/tech/chain-of-responsibility/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Chain of Responsibility</span>
  </a>
  <a class="next" href="https://isyuanpeng.github.io/posts/tech/kafka-commond/">
    <span class="title">Next Page »</span>
    <br>
    <span>论如何在没有Kafkatool的情况下存活</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://isyuanpeng.github.io/">Isyuanpeng</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
