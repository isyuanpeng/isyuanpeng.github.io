<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>一个基于Quic协议的Http转Udp代理工具 | Isyuanpeng</title>
<meta name="keywords" content="QUIC" />
<meta name="description" content="一个基于Quic协议的Http转Udp代理工具
背景
某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。
两个网络的边界端口映射有一个唯一的限制：两个网络之间端口映射只能映射Udp的端口
现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。
探索
针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。


TCP和UDP

处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP
TCP可靠，UDP不可靠



Http

处在TCP/IP模型的应用层中，基于tcp协议的应用



上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。
经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：

Udp不可靠，存在丢包的情况
Udp有报文大小限制，1480bytes
Udp不保证数据顺序

对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。
既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。
在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。
HTTP/3 &amp; Quic

HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]">
<meta name="author" content="yuanpeng11">
<link rel="canonical" href="https://isyuanpeng.github.io/posts/tech/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Equic%E5%8D%8F%E8%AE%AE%E7%9A%84http%E8%BD%ACudp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css" integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://isyuanpeng.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://isyuanpeng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://isyuanpeng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://isyuanpeng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://isyuanpeng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.140.1">
<link rel="alternate" hreflang="en" href="https://isyuanpeng.github.io/posts/tech/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Equic%E5%8D%8F%E8%AE%AE%E7%9A%84http%E8%BD%ACudp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="一个基于Quic协议的Http转Udp代理工具" />
<meta property="og:description" content="一个基于Quic协议的Http转Udp代理工具
背景
某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。
两个网络的边界端口映射有一个唯一的限制：两个网络之间端口映射只能映射Udp的端口
现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。
探索
针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。


TCP和UDP

处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP
TCP可靠，UDP不可靠



Http

处在TCP/IP模型的应用层中，基于tcp协议的应用



上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。
经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：

Udp不可靠，存在丢包的情况
Udp有报文大小限制，1480bytes
Udp不保证数据顺序

对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。
既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。
在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。
HTTP/3 &amp; Quic

HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://isyuanpeng.github.io/posts/tech/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Equic%E5%8D%8F%E8%AE%AE%E7%9A%84http%E8%BD%ACudp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/" /><meta property="og:image" content="https://isyuanpeng.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T11:39:30&#43;08:00" />
<meta property="article:modified_time" content="2023-11-25T11:39:30&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://isyuanpeng.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="一个基于Quic协议的Http转Udp代理工具"/>
<meta name="twitter:description" content="一个基于Quic协议的Http转Udp代理工具
背景
某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。
两个网络的边界端口映射有一个唯一的限制：两个网络之间端口映射只能映射Udp的端口
现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。
探索
针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。


TCP和UDP

处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP
TCP可靠，UDP不可靠



Http

处在TCP/IP模型的应用层中，基于tcp协议的应用



上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。
经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：

Udp不可靠，存在丢包的情况
Udp有报文大小限制，1480bytes
Udp不保证数据顺序

对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。
既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。
在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。
HTTP/3 &amp; Quic

HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://isyuanpeng.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "一个基于Quic协议的Http转Udp代理工具",
      "item": "https://isyuanpeng.github.io/posts/tech/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Equic%E5%8D%8F%E8%AE%AE%E7%9A%84http%E8%BD%ACudp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "一个基于Quic协议的Http转Udp代理工具",
  "name": "一个基于Quic协议的Http转Udp代理工具",
  "description": "一个基于Quic协议的Http转Udp代理工具 背景 某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。\n两个网络的边界端口映射有一个唯一的限制：两个网络之间端口映射只能映射Udp的端口\n现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。\n探索 针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。\nTCP和UDP\n处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP TCP可靠，UDP不可靠 Http\n处在TCP/IP模型的应用层中，基于tcp协议的应用 上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。\n经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：\nUdp不可靠，存在丢包的情况 Udp有报文大小限制，1480bytes Udp不保证数据顺序 对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。\n既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。\n在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。\nHTTP/3 \u0026amp; Quic HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]\n",
  "keywords": [
    "QUIC"
  ],
  "articleBody": "一个基于Quic协议的Http转Udp代理工具 背景 某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。\n两个网络的边界端口映射有一个唯一的限制：两个网络之间端口映射只能映射Udp的端口\n现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。\n探索 针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。\nTCP和UDP\n处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP TCP可靠，UDP不可靠 Http\n处在TCP/IP模型的应用层中，基于tcp协议的应用 上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。\n经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：\nUdp不可靠，存在丢包的情况 Udp有报文大小限制，1480bytes Udp不保证数据顺序 对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。\n既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。\n在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。\nHTTP/3 \u0026 Quic HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]\n通过维基百科我们可以了解到HTTP3使用一种基于UDP多路复用的QUIC协议，同时它也实现了Http/1.1和Http/2。\n通过协议栈我们可以发现，QUIC = HTTP/2 + TLS + UDP。\nQuic协议是由google设计的，全称Quick UDP Internet Connections，由于目前互联网中大量的存量设备都是使用的Http协议，所以并没有继续在tcp协议上进行大的改动升级Http，而是使用了全新的Udp来完成Http。\nHTTP/3的开源实现 HTTP/3的开源实现并不多，主要C++，C#，Go，Rust语言上，其中目前使用最为广泛的应该是Cloudflare的quiche(https://github.com/cloudflare/quiche)，\n其实在看到很多quick的实际应用，都是针对某个单体网站去进行http3的应用。\n初次尝试 quiche-nginx 看了一些项目，初步的一个想法我在两个网络部署支持http3的nginx，然后通过nginx转发请求达到代理的效果。\nquiche的nginx版本需要在nginx1.16.1版本上打quiche http3的patch，然后重新编译nginx，此次尝试耗时很久，实际结果却不尽如人意，整个编译链需要的很多库都需要联网下载，内网离线安装费时费力。编译完成后开启http3配置也接收不到请求。此次尝试以失败告终。\n同时也在思考，就算该种方法成功，后期交付和维护也是很大的问题，将会浪费很多时间。\n再次尝试 kwik 由于本人是Java开发，考虑到整个部门也是Java居多，如果用Java实现，后期维护比较方便。而且以组件的形式开发，交付和复用也比较方便。基于这样的考虑，进行了第二次的尝试，Http3的Java开源实现kwik(https://github.com/ptrd/kwik)。\n这次的尝试就比较顺畅了，由于已经使用udp测试工具测试过udp通道的正常，而且kwik中已经实现好了client端和server端，所以只需要在B网络部署serevr端的jar包，A网络用client端的jar包去调用即可。\nkwik的server端内置了一个/getVersion的接口，在A网络用client去调用B网络server端的/getVersion请求，成功进行了返回。\n随后又在server写死了一个平台侧的请求，继续调用，也成功进行了返回。在完成测试后，下面开始准备魔改kwik，让其满足我们的业务需求。\nKwik kwik-client kwik只实现了quick协议，对于如何使用需要自行定义。\n那这里我们作为一个http的代理工具，client端要进行的定制也是非常清晰明了，起一个Http的服务器接收请求，针对每个请求，http协议转quic协议，使用kwik client去调用即可。\n有了整体的实现逻辑，那么代码实现起来也比较简单，这里看一些关键的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //1. 创建一个HttpServer实例，并绑定到指定的端口号 HttpServer httpServer = HttpServer.create(new InetSocketAddress(listenPort), 0); httpServer.createContext(\"/\", customHttpHandler); httpServer.start(); // 2. 创建自定义的HttpHandler 完成http协议到quic协议的转换 QuicClientConnection.Builder builder = QuicClientConnection.newBuilder(); // 这里的serverIp 和 serverPort为kwik-server的ip和port builder.uri(new URI(\"//\" + serverIp + \":\" + serverPort)); QuicClientConnection quicConnection = builder.build(); HttpClient httpClient = createHttpClient(quicConnection, false); HttpRequest.Builder httpBuilder = HttpRequest.newBuilder(); HttpRequest httpRequest = httpBuilder.GET().build(); // 3. 调用kwik-server, 返回的请求统一用String去接, 针对某些特殊请求,图片等 server端使用转base64返回, 这里拿到String方便解base64 HttpResponse httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString()); // 4. ... 省略一些处理 // 5. 写回返回流 OutputStream outputStream = exchange.getResponseBody(); outputStream.write(responseBytes); outputStream.close(); 至此，完成了client侧的定制。\nkwik-server 那么对于server端，我们的定制内容也是比较清晰，kwik-client端发送来的请求，quic协议转http协议，然后调用平台的接口，返回结果接口。\n下面看一些核心的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 1. 开启一个quic connections，在listenPort上的udp socket，监听请求 ServerConnector serverConnector = new ServerConnector(listenPort, new FileInputStream(certificateFile), new FileInputStream(certificateKeyFile), supportedVersions, true, log); registerHttp3(serverConnector); serverConnector.start(); // 2. 根据路径区分不同类型的请求，并进行定制处理 if (request.path().startsWith(ServerType.FILE.getPath())) { // 文件服务器 可以摆渡/home下的文件 homeFileServer.handleRequest(request, response); } else if (request.path().startsWith(ServerType.IMAGE.getPath())) { httpImageServer.handleRequest(request, response); } else if (request.path().startsWith(ServerType.APP_FILE.getPath())) { fileServer.handleRequest(request, response); }else { requestHandler.handleRequest(request, response); } // 3. 实现不同的http请求server，进行不同的处理， // HomeFileServer: 文件摆渡 // HttpImage: 图片请求 // FileServer: APP文件下载请求 // RequestHandler: 默认HTTP请求处理 整体源码流程 术语 首先定义一些术语，方便大家观看\nHttp3Connection: Http3 Client端的连接类 Http3Client: Http3 Client，负责发送请求 QuicStream: Quic协议一次请求的流信息的定义，持有inputStream和outputStream，负责输入输出的写入。 ServerConnection: http3 Server端的连接类 Sender、Receiver: 请求发送和接收的实际操作类 定制部分比较少，流程也比较清晰，主要还是要看一下kwik是如何实现QUIC协议的，这里从源码出发，由Client至Server，进行一步步的解析。\nClient端 请求的发送其实在JDK11内置的HttpClient上进行扩展的。\nkwik定义了Http3Client，继承自java.net.http.HttpClient，我们上面的实现中，client端请求发出就是用的该类，Http3Client重写了send方法。\n1 2 3 4 5 6 @Override public HttpResponse send(HttpRequest request, HttpResponse.BodyHandler responseBodyHandler) throws IOException { http3Connection = http3ConnectionFactory.getConnection(request); http3Connection.connect((int) connectTimeout().orElse(DEFAULT_CONNECT_TIMEOUT).toMillis()); return http3Connection.send(request, responseBodyHandler); } 第一行getConnection实际上就是创建http3Connection, 由于QUIC是实现Http3的一种协议，所以，这里Http3Connection实际只持有和管理QuicClientConnection，以及一些请求控制参数。\n那么创建Http3Connection实际上就是创建QuicClientConnection，QuicClientConnection持有了一个sender和receiver，sender负责发送请求，receiver负责接收请求返回信息。\n1 2 3 4 socket = new DatagramSocket(); sender = new SenderImpl(quicVersion, getMaxPacketSize(), socket, new InetSocketAddress(serverAddress, port), this, initialRtt, log); receiver = new Receiver(socket, log, this::abortConnection); 这里就比较清晰了，先是创建了个UDP的socket，然后sender使用这个socket往new InetSocketAddress(serverAddress, port)这个地址发送数据, receiver从socket中接收数据, sender和receiver都是各起了一个线程。\nHttp3Connection创建好后，开始connect，connect中主要分了两个动作，QuicClientConnection的建立和client端请求参数的配置，这里咱们主要关注quicConnection的实现，\n1 2 3 4 5 if (!quicConnection.isConnected()) { Version quicVersion = determinePreferredQuicVersion(); String applicationProtocol = quicVersion.equals(Version.QUIC_version_1) ? \"h3\" : determineH3Version(quicVersion); quicConnection.connect(connectTimeoutInMillis, applicationProtocol, null, Collections.emptyList()); } 第一行确认版本，第二行确认协议，还是聚焦在第三行QuicClientConnection的connect中：\n1 2 3 receiver.start(); sender.start(connectionSecrets); startHandshake(applicationProtocol, !earlyData.isEmpty()); QuicClientConnection的connect就是用刚刚启动刚刚定义的sender和receiver线程，那这里比较关键的是startHandshake, 之前我们也说了UDP是不可靠的，那么QUIC是如何实现可靠的呢？就是依靠的和TCP一样的机制，握手。\n在刚刚QuicClientConnection创建的时候，还创建了ClientMessageSender的实现类、：\n1 2 3 4 5 6 7 8 9 10 public interface ClientMessageSender { void send(ClientHello clientHello) throws IOException; void send(FinishedMessage finishedMessage) throws IOException; void send(CertificateMessage certificateMessage) throws IOException; void send(CertificateVerifyMessage certificateVerifyMessage); } 那看到这我们应该很熟悉了，在startHandshake中，先发送clientHello，同样对应的在server端收到serverHello后，会发送serverHello。\n需要注意的是，这里的握手并不是实现了TCP的三次握手，四次挥手。HTTP3用了最新的TLS1.3, TLS1.3中定义了0-RTT(一次握手)，1-RTT(两次握手)等等，有兴趣的可以了解一下。\n具体的握手细节可以从抓包上清楚的看到：\nStep1: client发送了ClientHello，并且携带了各种key\nStep2: server发送了Retry, 因为server端持有的connectionId和client发送的DCID(destination connection id)相等了，所以要求client重新handshake\nStep3: client重新发送Initial packet, 可以看到，这里用了server的Retry packet的DCID\nStep4: server发送ServerHello，然后包括了HandShake，TLS的各种信息\nStep5: client进行HandShake，TLS的各种信息\nStep6: 开始传输message\n在整个过程中，只有ClientHello和ServerHello是明文的，其余都是加密的。\n握手成功后，就开始真正的send了，主要在下面代码的第二行和第三行中，第一行根据当前的connection创建一个stream出来，QuicStream包含了StreamInputStream和StreamOutputStream，自定义了输入和输出流。\n同时其中也包含了除了请求header和body之外的协议信息，创建QuicStream相当于创建了个模板，后续只需要填充header和body。\n1 2 3 4 5 6 public HttpResponse send(HttpRequest request, HttpResponse.BodyHandler responseBodyHandler) throws IOException { QuicStream httpStream = quicConnection.createStream(true); sendRequest(request, httpStream); Http3Response http3Response = receiveResponse(request, responseBodyHandler, httpStream); return http3Response; } 当sendRequest(request, httpStream);时，将request的header和body都写到QuicStream的StreamOutputStream中去，而该QuicStream也push到RequestQueue中。\n存入requestQueue后，通知最初定义的sender, sender将请求输出到socket中去。\nreceiveResponse(request, responseBodyHandler, httpStream);拉取请求返回结果，当server处理完请求后，会将返回结果发送到socket中，最初定义的receiver一直在拉取请求结果信息。\n最终将结果写入到httpStream的inputStream中，receiveResponse将返回的信息返回到http request中去。\n上述只是最简单的实现描述，真实的代码非常复杂，TLS的处理、以及不同过程的数据处理，以及数据拆分等等等等。\nServer端 Server端首先用配置好的port新建一个socket，这个port就是上面client端的socket发送的port。同样的新建一个Receiver去接收client端发送的请求。\n1 2 new DatagramSocket(port) receiver = new Receiver(serverSocket, log, exception -\u003e System.exit(9)); 定义了一个receivedPacketsQueue去存放接收的消息，然后将接收到的消息进行处理。\n1 2 3 4 5 receiverThread = new Thread(() -\u003e run(), \"receiver\"); receiverThread.setDaemon(true); receivedPacketsQueue = new LinkedBlockingQueue\u003c\u003e(); RawPacket rawPacket = receiver.get((int) Duration.ofDays(10 * 365).toSeconds()); process(rawPacket); 1 2 3 4 5 6 7 8 9 10 11 12 protected void process(RawPacket rawPacket) { ByteBuffer data = rawPacket.getData(); int flags = data.get(); data.rewind(); if ((flags \u0026 0b1100_0000) == 0b1100_0000) { processLongHeaderPacket(new InetSocketAddress(rawPacket.getAddress(), rawPacket.getPort()), data); } else if ((flags \u0026 0b1100_0000) == 0b0100_0000) { processShortHeaderPacket(new InetSocketAddress(rawPacket.getAddress(), rawPacket.getPort()), data); } else { log.warn(String.format(\"Invalid Quic packet (flags: %02x) is discarded\", flags)); } } 数据的处理主要分为两种类型，一种是Long header packet，long header主要是初始化和handshake的时候使用的。而short header是除了long header以外普通的packet。\n第一次接收数据时并处理时，创建一个ServerConnection，在ServerConnection中，只有一个sender，和Client的做法类似，有一个ServerMessageSender去发送ServerHello和handshake。\nLong header packet的数据处理完后，也就完成了和client端的handshake。后面就处理short header的数据，处理后的packet解析成http1的请求，http1的请求经过定制后，得到http1的response。\nresponse写入QuicStream中，和client端的send一样，由ServerConnection中的sender去发送返回结果。\n如何解决的UDP的问题 开头我们说了UDP通讯的三个问题：\nUdp不可靠，存在丢包的情况 Udp有报文大小限制，1480bytes Udp不保证数据顺序 Quic的解决方案如下：\n如果发送的数据server端没有响应，就会一直重发，直到服务端响应 发送数据前拆包 在1的基础上，每个数据包都有一个offset，最后根据offset组装数据 ",
  "wordCount" : "644",
  "inLanguage": "en",
  "datePublished": "2023-11-25T11:39:30+08:00",
  "dateModified": "2023-11-25T11:39:30+08:00",
  "author":[{
    "@type": "Person",
    "name": "yuanpeng11"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://isyuanpeng.github.io/posts/tech/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Equic%E5%8D%8F%E8%AE%AE%E7%9A%84http%E8%BD%ACudp%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Isyuanpeng",
    "logo": {
      "@type": "ImageObject",
      "url": "https://isyuanpeng.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://isyuanpeng.github.io/" accesskey="h" title="Isyuanpeng (Alt + H)">Isyuanpeng</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://isyuanpeng.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="https://isyuanpeng.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://isyuanpeng.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://isyuanpeng.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      一个基于Quic协议的Http转Udp代理工具
    </h1>
    <div class="post-meta">&lt;span title=&#39;2023-11-25 11:39:30 &#43;0800 &#43;0800&#39;&gt;November 25, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;yuanpeng11

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e4%b8%80%e4%b8%aa%e5%9f%ba%e4%ba%8equic%e5%8d%8f%e8%ae%ae%e7%9a%84http%e8%bd%acudp%e4%bb%a3%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="一个基于Quic协议的Http转Udp代理工具">一个基于Quic协议的Http转Udp代理工具</a><ul>
                            
                    <li>
                        <a href="#%e8%83%8c%e6%99%af" aria-label="背景">背景</a></li>
                    <li>
                        <a href="#%e6%8e%a2%e7%b4%a2" aria-label="探索">探索</a><ul>
                            
                    <li>
                        <a href="#http3--quic" aria-label="HTTP/3 &amp; Quic">HTTP/3 &amp; Quic</a></li>
                    <li>
                        <a href="#http3%e7%9a%84%e5%bc%80%e6%ba%90%e5%ae%9e%e7%8e%b0" aria-label="HTTP/3的开源实现">HTTP/3的开源实现</a></li>
                    <li>
                        <a href="#%e5%88%9d%e6%ac%a1%e5%b0%9d%e8%af%95-quiche-nginx" aria-label="初次尝试 quiche-nginx">初次尝试 quiche-nginx</a></li>
                    <li>
                        <a href="#%e5%86%8d%e6%ac%a1%e5%b0%9d%e8%af%95-kwik" aria-label="再次尝试 kwik">再次尝试 kwik</a></li></ul>
                    </li>
                    <li>
                        <a href="#kwik" aria-label="Kwik">Kwik</a><ul>
                            
                    <li>
                        <a href="#kwik-client" aria-label="kwik-client">kwik-client</a></li>
                    <li>
                        <a href="#kwik-server" aria-label="kwik-server">kwik-server</a></li>
                    <li>
                        <a href="#%e6%95%b4%e4%bd%93%e6%ba%90%e7%a0%81%e6%b5%81%e7%a8%8b" aria-label="整体源码流程">整体源码流程</a><ul>
                            
                    <li>
                        <a href="#%e6%9c%af%e8%af%ad" aria-label="术语">术语</a></li>
                    <li>
                        <a href="#client%e7%ab%af" aria-label="Client端">Client端</a></li>
                    <li>
                        <a href="#server%e7%ab%af" aria-label="Server端">Server端</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e7%9a%84udp%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="如何解决的UDP的问题">如何解决的UDP的问题</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="一个基于quic协议的http转udp代理工具">一个基于Quic协议的Http转Udp代理工具<a hidden class="anchor" aria-hidden="true" href="#一个基于quic协议的http转udp代理工具">#</a></h1>
<h2 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h2>
<p>某地存在A和B两个网络，A中搭建了上级平台，用户平时正常办公使用该平台。B搭建了下级平台，接入设备。</p>
<p>两个网络的边界端口映射有一个唯一的限制：<strong>两个网络之间端口映射只能映射Udp的端口</strong></p>
<p>现在B网中的设备想要接入A网，B网中的设备接入基本上都是http请求，所以整体的对接只需要对接http请求。</p>
<h2 id="探索">探索<a hidden class="anchor" aria-hidden="true" href="#探索">#</a></h2>
<p>针对该问题，进行相关的预研探索。目前已有的条件就是udp通道的边界，那么实现该目标的办法就是利用该udp通道去传输http请求，也就是说要开发http-udp，udp-http的代理工具。</p>
<ul>
<li>
<p>TCP和UDP</p>
<ul>
<li>处在TCP/IP模型的传输层中，传输控制协议TCP和用户数据报协议UDP</li>
<li>TCP可靠，UDP不可靠</li>
</ul>
</li>
<li>
<p>Http</p>
<ul>
<li>处在TCP/IP模型的应用层中，基于tcp协议的应用</li>
</ul>
</li>
</ul>
<p>上述的概念比较清晰，其中也暴露了一个非常关键的点，TCP可靠，UDP不可靠。我们都知道tcp的三次握手和四次挥手，tcp是面向连接的协议，通过严格的确认连接来保证整个连接的正常通信。而udp面向非连接，不需要维护连接状态，只需要交付报文即可。</p>
<p>经过一些了解后，如果要开发一个http和udp互相转换的代理工具，主要需要解决以下的问题：</p>
<ol>
<li>Udp不可靠，存在丢包的情况</li>
<li>Udp有报文大小限制，1480bytes</li>
<li>Udp不保证数据顺序</li>
</ol>
<p>对于一个网络方面的小白来说，想要独自开发上述代理工具至少需要半年起步。</p>
<p>既然从0开发需要耗时太长，那么就需要找目前已经存在的代理工具，经过搜索发现相关内容少之又少。</p>
<p>在一次偶然的搜索中发现http3.0是基于Quic协议开发，而Quic协议又是基于udp的，那么似乎找到了一丝问题解决的可能性。</p>
<h3 id="http3--quic">HTTP/3 &amp; Quic<a hidden class="anchor" aria-hidden="true" href="#http3--quic">#</a></h3>
<blockquote>
<p>HTTP/3 is the third major version of the Hypertext Transfer Protocol used to exchange information on the World Wide Web, complementing the widely-deployed HTTP/1.1 and HTTP/2. Unlike previous versions which relied on the well-established TCP (published in 1974),[2] HTTP/3 uses QUIC, a multiplexed transport protocol built on UDP.[3] On 6 June 2022, IETF published HTTP/3 as a Proposed Standard in RFC 9114.[4]</p>
</blockquote>
<p>通过维基百科我们可以了解到HTTP3使用一种基于UDP多路复用的QUIC协议，同时它也实现了Http/1.1和Http/2。</p>
<p><img loading="lazy" src="https://pic4.zhimg.com/80/v2-d61a62fdfb08ed3882e1018136ce6b2f_1440w.webp" alt="Quic"  title="Quic"  />
</p>
<p>通过协议栈我们可以发现，QUIC = HTTP/2 + TLS + UDP。</p>
<p>Quic协议是由google设计的，全称Quick UDP Internet Connections，由于目前互联网中大量的存量设备都是使用的Http协议，所以并没有继续在tcp协议上进行大的改动升级Http，而是使用了全新的Udp来完成Http。</p>
<h3 id="http3的开源实现">HTTP/3的开源实现<a hidden class="anchor" aria-hidden="true" href="#http3的开源实现">#</a></h3>
<p>HTTP/3的开源实现并不多，主要C++，C#，Go，Rust语言上，其中目前使用最为广泛的应该是Cloudflare的quiche(<a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a>)，</p>
<p><img loading="lazy" src="../image/http3-implement.png" alt="http3_implement"  title="http3_implement"  />
</p>
<p>其实在看到很多quick的实际应用，都是针对某个单体网站去进行http3的应用。</p>
<h3 id="初次尝试-quiche-nginx">初次尝试 quiche-nginx<a hidden class="anchor" aria-hidden="true" href="#初次尝试-quiche-nginx">#</a></h3>
<p>看了一些项目，初步的一个想法我在两个网络部署支持http3的nginx，然后通过nginx转发请求达到代理的效果。</p>
<p><img loading="lazy" src="../image/udp-process-simple.png" alt="http3_nginx"  title="http3_nginx"  />
</p>
<p>quiche的nginx版本需要在nginx1.16.1版本上打quiche http3的patch，然后重新编译nginx，此次尝试耗时很久，实际结果却不尽如人意，整个编译链需要的很多库都需要联网下载，内网离线安装费时费力。编译完成后开启http3配置也接收不到请求。此次尝试以失败告终。</p>
<p>同时也在思考，就算该种方法成功，后期交付和维护也是很大的问题，将会浪费很多时间。</p>
<h3 id="再次尝试-kwik">再次尝试 kwik<a hidden class="anchor" aria-hidden="true" href="#再次尝试-kwik">#</a></h3>
<p>由于本人是Java开发，考虑到整个部门也是Java居多，如果用Java实现，后期维护比较方便。而且以组件的形式开发，交付和复用也比较方便。基于这样的考虑，进行了第二次的尝试，Http3的Java开源实现kwik(<a href="https://github.com/ptrd/kwik">https://github.com/ptrd/kwik</a>)。</p>
<p>这次的尝试就比较顺畅了，由于已经使用udp测试工具测试过udp通道的正常，而且kwik中已经实现好了client端和server端，所以只需要在B网络部署serevr端的jar包，A网络用client端的jar包去调用即可。</p>
<p>kwik的server端内置了一个/getVersion的接口，在A网络用client去调用B网络server端的/getVersion请求，成功进行了返回。</p>
<p>随后又在server写死了一个平台侧的请求，继续调用，也成功进行了返回。在完成测试后，下面开始准备魔改kwik，让其满足我们的业务需求。</p>
<h2 id="kwik">Kwik<a hidden class="anchor" aria-hidden="true" href="#kwik">#</a></h2>
<h3 id="kwik-client">kwik-client<a hidden class="anchor" aria-hidden="true" href="#kwik-client">#</a></h3>
<p>kwik只实现了quick协议，对于如何使用需要自行定义。</p>
<p>那这里我们作为一个http的代理工具，client端要进行的定制也是非常清晰明了，起一个Http的服务器接收请求，针对每个请求，http协议转quic协议，使用kwik client去调用即可。</p>
<p><img loading="lazy" src="../image/quic-client-call.png" alt="kwik-client"  title="kwik-client"  />
</p>
<p>有了整体的实现逻辑，那么代码实现起来也比较简单，这里看一些关键的代码:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  //1. 创建一个HttpServer实例，并绑定到指定的端口号
</span></span><span style="display:flex;"><span>  HttpServer httpServer = HttpServer.create(new InetSocketAddress(listenPort), 0);
</span></span><span style="display:flex;"><span>  httpServer.createContext(&#34;/&#34;, customHttpHandler);
</span></span><span style="display:flex;"><span>  httpServer.start();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>  // 2. 创建自定义的HttpHandler 完成http协议到quic协议的转换
</span></span><span style="display:flex;"><span>  QuicClientConnection.Builder builder = QuicClientConnection.newBuilder();
</span></span><span style="display:flex;"><span>  // 这里的serverIp 和 serverPort为kwik-server的ip和port
</span></span><span style="display:flex;"><span>  builder.uri(new URI(&#34;//&#34; + serverIp + &#34;:&#34; + serverPort));
</span></span><span style="display:flex;"><span>  QuicClientConnection quicConnection = builder.build();
</span></span><span style="display:flex;"><span>  HttpClient httpClient = createHttpClient(quicConnection, false);
</span></span><span style="display:flex;"><span>  HttpRequest.Builder httpBuilder = HttpRequest.newBuilder();
</span></span><span style="display:flex;"><span>  HttpRequest httpRequest = httpBuilder.GET().build();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  // 3. 调用kwik-server, 返回的请求统一用String去接, 针对某些特殊请求,图片等 server端使用转base64返回, 这里拿到String方便解base64
</span></span><span style="display:flex;"><span>  HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  // 4. ... 省略一些处理
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  // 5. 写回返回流
</span></span><span style="display:flex;"><span>  OutputStream outputStream = exchange.getResponseBody();
</span></span><span style="display:flex;"><span>  outputStream.write(responseBytes);
</span></span><span style="display:flex;"><span>  outputStream.close();
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，完成了client侧的定制。</p>
<h3 id="kwik-server">kwik-server<a hidden class="anchor" aria-hidden="true" href="#kwik-server">#</a></h3>
<p>那么对于server端，我们的定制内容也是比较清晰，kwik-client端发送来的请求，quic协议转http协议，然后调用平台的接口，返回结果接口。</p>
<p><img loading="lazy" src="../image/quic-server-call.png" alt="kwik-server"  title="kwik-server"  />
</p>
<p>下面看一些核心的代码：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  // 1. 开启一个quic connections，在listenPort上的udp socket，监听请求
</span></span><span style="display:flex;"><span>  ServerConnector serverConnector = new ServerConnector(listenPort, new FileInputStream(certificateFile), new FileInputStream(certificateKeyFile), supportedVersions, true, log);
</span></span><span style="display:flex;"><span>  registerHttp3(serverConnector);
</span></span><span style="display:flex;"><span>  serverConnector.start();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  // 2. 根据路径区分不同类型的请求，并进行定制处理
</span></span><span style="display:flex;"><span>  if (request.path().startsWith(ServerType.FILE.getPath())) {
</span></span><span style="display:flex;"><span>      // 文件服务器 可以摆渡/home下的文件
</span></span><span style="display:flex;"><span>      homeFileServer.handleRequest(request, response);
</span></span><span style="display:flex;"><span>  } else if (request.path().startsWith(ServerType.IMAGE.getPath())) {
</span></span><span style="display:flex;"><span>      httpImageServer.handleRequest(request, response);
</span></span><span style="display:flex;"><span>  } else if (request.path().startsWith(ServerType.APP_FILE.getPath())) {
</span></span><span style="display:flex;"><span>      fileServer.handleRequest(request, response);
</span></span><span style="display:flex;"><span>  }else {
</span></span><span style="display:flex;"><span>      requestHandler.handleRequest(request, response);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  // 3. 实现不同的http请求server，进行不同的处理，
</span></span><span style="display:flex;"><span>  // HomeFileServer: 文件摆渡
</span></span><span style="display:flex;"><span>  // HttpImage: 图片请求
</span></span><span style="display:flex;"><span>  // FileServer: APP文件下载请求
</span></span><span style="display:flex;"><span>  // RequestHandler: 默认HTTP请求处理
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="整体源码流程">整体源码流程<a hidden class="anchor" aria-hidden="true" href="#整体源码流程">#</a></h3>
<h4 id="术语">术语<a hidden class="anchor" aria-hidden="true" href="#术语">#</a></h4>
<p>首先定义一些术语，方便大家观看</p>
<ol>
<li>Http3Connection: Http3 Client端的连接类</li>
<li>Http3Client: Http3 Client，负责发送请求</li>
<li>QuicStream: Quic协议一次请求的流信息的定义，持有inputStream和outputStream，负责输入输出的写入。</li>
<li>ServerConnection: http3 Server端的连接类</li>
<li>Sender、Receiver: 请求发送和接收的实际操作类</li>
</ol>
<p>定制部分比较少，流程也比较清晰，主要还是要看一下kwik是如何实现QUIC协议的，这里从源码出发，由Client至Server，进行一步步的解析。</p>
<h4 id="client端">Client端<a hidden class="anchor" aria-hidden="true" href="#client端">#</a></h4>
<p>请求的发送其实在JDK11内置的HttpClient上进行扩展的。</p>
<p>kwik定义了Http3Client，继承自java.net.http.HttpClient，我们上面的实现中，client端请求发出就是用的该类，Http3Client重写了send方法。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    @Override
</span></span><span style="display:flex;"><span>    public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest request, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler) throws IOException {
</span></span><span style="display:flex;"><span>        http3Connection = http3ConnectionFactory.getConnection(request);
</span></span><span style="display:flex;"><span>        http3Connection.connect((int) connectTimeout().orElse(DEFAULT_CONNECT_TIMEOUT).toMillis());
</span></span><span style="display:flex;"><span>        return http3Connection.send(request, responseBodyHandler);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一行getConnection实际上就是创建http3Connection, 由于QUIC是实现Http3的一种协议，所以，这里Http3Connection实际只持有和管理QuicClientConnection，以及一些请求控制参数。</p>
<p>那么创建Http3Connection实际上就是创建QuicClientConnection，QuicClientConnection持有了一个sender和receiver，sender负责发送请求，receiver负责接收请求返回信息。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>        socket = new DatagramSocket();
</span></span><span style="display:flex;"><span>        sender = new SenderImpl(quicVersion, getMaxPacketSize(), socket, new InetSocketAddress(serverAddress, port),
</span></span><span style="display:flex;"><span>                        this, initialRtt, log);
</span></span><span style="display:flex;"><span>        receiver = new Receiver(socket, log, this::abortConnection);
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里就比较清晰了，先是创建了个UDP的socket，然后sender使用这个socket往new InetSocketAddress(serverAddress, port)这个地址发送数据, receiver从socket中接收数据, sender和receiver都是各起了一个线程。</p>
<p>Http3Connection创建好后，开始connect，connect中主要分了两个动作，QuicClientConnection的建立和client端请求参数的配置，这里咱们主要关注quicConnection的实现，</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    if (!quicConnection.isConnected()) {
</span></span><span style="display:flex;"><span>        Version quicVersion = determinePreferredQuicVersion();
</span></span><span style="display:flex;"><span>        String applicationProtocol = quicVersion.equals(Version.QUIC_version_1) ? &#34;h3&#34; : determineH3Version(quicVersion);
</span></span><span style="display:flex;"><span>        quicConnection.connect(connectTimeoutInMillis, applicationProtocol, null, Collections.emptyList());
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一行确认版本，第二行确认协议，还是聚焦在第三行QuicClientConnection的connect中：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>        receiver.start();
</span></span><span style="display:flex;"><span>        sender.start(connectionSecrets);
</span></span><span style="display:flex;"><span>        startHandshake(applicationProtocol, !earlyData.isEmpty());
</span></span></code></pre></td></tr></table>
</div>
</div><p>QuicClientConnection的connect就是用刚刚启动刚刚定义的sender和receiver线程，那这里比较关键的是startHandshake, 之前我们也说了UDP是不可靠的，那么QUIC是如何实现可靠的呢？就是依靠的和TCP一样的机制，握手。</p>
<p>在刚刚QuicClientConnection创建的时候，还创建了ClientMessageSender的实现类、：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public interface ClientMessageSender {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void send(ClientHello clientHello) throws IOException;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void send(FinishedMessage finishedMessage) throws IOException;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void send(CertificateMessage certificateMessage) throws IOException;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void send(CertificateVerifyMessage certificateVerifyMessage);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那看到这我们应该很熟悉了，在startHandshake中，先发送clientHello，同样对应的在server端收到serverHello后，会发送serverHello。</p>
<p>需要注意的是，这里的握手并不是实现了TCP的三次握手，四次挥手。HTTP3用了最新的TLS1.3, TLS1.3中定义了0-RTT(一次握手)，1-RTT(两次握手)等等，有兴趣的可以了解一下。</p>
<p>具体的握手细节可以从抓包上清楚的看到：</p>
<p><img loading="lazy" src="../image/quic-wireshark.png" alt="quic-wireshark"  title="quic-wireshark"  />
</p>
<ul>
<li>
<p>Step1: client发送了ClientHello，并且携带了各种key</p>
</li>
<li>
<p>Step2: server发送了Retry, 因为server端持有的connectionId和client发送的DCID(destination connection id)相等了，所以要求client重新handshake</p>
</li>
<li>
<p>Step3: client重新发送Initial packet, 可以看到，这里用了server的Retry packet的DCID</p>
</li>
<li>
<p>Step4: server发送ServerHello，然后包括了HandShake，TLS的各种信息</p>
</li>
<li>
<p>Step5: client进行HandShake，TLS的各种信息</p>
</li>
<li>
<p>Step6: 开始传输message</p>
</li>
</ul>
<p>在整个过程中，只有ClientHello和ServerHello是明文的，其余都是加密的。</p>
<p>握手成功后，就开始真正的send了，主要在下面代码的第二行和第三行中，第一行根据当前的connection创建一个stream出来，QuicStream包含了StreamInputStream和StreamOutputStream，自定义了输入和输出流。</p>
<p>同时其中也包含了除了请求header和body之外的协议信息，创建QuicStream相当于创建了个模板，后续只需要填充header和body。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest request, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler) throws IOException {
</span></span><span style="display:flex;"><span>        QuicStream httpStream = quicConnection.createStream(true);
</span></span><span style="display:flex;"><span>        sendRequest(request, httpStream);
</span></span><span style="display:flex;"><span>        Http3Response&lt;T&gt; http3Response = receiveResponse(request, responseBodyHandler, httpStream);
</span></span><span style="display:flex;"><span>        return http3Response;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>当<code>sendRequest(request, httpStream);</code>时，将request的header和body都写到QuicStream的StreamOutputStream中去，而该QuicStream也push到RequestQueue中。</p>
<p>存入requestQueue后，通知最初定义的sender, sender将请求输出到socket中去。</p>
<p><code>receiveResponse(request, responseBodyHandler, httpStream);</code>拉取请求返回结果，当server处理完请求后，会将返回结果发送到socket中，最初定义的receiver一直在拉取请求结果信息。</p>
<p>最终将结果写入到httpStream的inputStream中，receiveResponse将返回的信息返回到http request中去。</p>
<p>上述只是最简单的实现描述，真实的代码非常复杂，TLS的处理、以及不同过程的数据处理，以及数据拆分等等等等。</p>
<h4 id="server端">Server端<a hidden class="anchor" aria-hidden="true" href="#server端">#</a></h4>
<p>Server端首先用配置好的port新建一个socket，这个port就是上面client端的socket发送的port。同样的新建一个Receiver去接收client端发送的请求。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>        new DatagramSocket(port)
</span></span><span style="display:flex;"><span>        receiver = new Receiver(serverSocket, log, exception -&gt; System.exit(9));
</span></span></code></pre></td></tr></table>
</div>
</div><p>定义了一个receivedPacketsQueue去存放接收的消息，然后将接收到的消息进行处理。</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>        receiverThread = new Thread(() -&gt; run(), &#34;receiver&#34;);
</span></span><span style="display:flex;"><span>        receiverThread.setDaemon(true);
</span></span><span style="display:flex;"><span>        receivedPacketsQueue = new LinkedBlockingQueue&lt;&gt;();
</span></span><span style="display:flex;"><span>        RawPacket rawPacket = receiver.get((int) Duration.ofDays(10 * 365).toSeconds());
</span></span><span style="display:flex;"><span>        process(rawPacket);
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    protected void process(RawPacket rawPacket) {
</span></span><span style="display:flex;"><span>        ByteBuffer data = rawPacket.getData();
</span></span><span style="display:flex;"><span>        int flags = data.get();
</span></span><span style="display:flex;"><span>        data.rewind();
</span></span><span style="display:flex;"><span>        if ((flags &amp; 0b1100_0000) == 0b1100_0000) {
</span></span><span style="display:flex;"><span>            processLongHeaderPacket(new InetSocketAddress(rawPacket.getAddress(), rawPacket.getPort()), data);
</span></span><span style="display:flex;"><span>        } else if ((flags &amp; 0b1100_0000) == 0b0100_0000) {
</span></span><span style="display:flex;"><span>            processShortHeaderPacket(new InetSocketAddress(rawPacket.getAddress(), rawPacket.getPort()), data);
</span></span><span style="display:flex;"><span>        } else {
</span></span><span style="display:flex;"><span>            log.warn(String.format(&#34;Invalid Quic packet (flags: %02x) is discarded&#34;, flags));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>数据的处理主要分为两种类型，一种是Long header packet，long header主要是初始化和handshake的时候使用的。而short header是除了long header以外普通的packet。</p>
<p>第一次接收数据时并处理时，创建一个ServerConnection，在ServerConnection中，只有一个sender，和Client的做法类似，有一个<code>ServerMessageSender</code>去发送ServerHello和handshake。</p>
<p>Long header packet的数据处理完后，也就完成了和client端的handshake。后面就处理short header的数据，处理后的packet解析成http1的请求，http1的请求经过定制后，得到http1的response。</p>
<p>response写入QuicStream中，和client端的send一样，由ServerConnection中的sender去发送返回结果。</p>
<h3 id="如何解决的udp的问题">如何解决的UDP的问题<a hidden class="anchor" aria-hidden="true" href="#如何解决的udp的问题">#</a></h3>
<p>开头我们说了UDP通讯的三个问题：</p>
<ol>
<li>Udp不可靠，存在丢包的情况</li>
<li>Udp有报文大小限制，1480bytes</li>
<li>Udp不保证数据顺序</li>
</ol>
<p>Quic的解决方案如下：</p>
<ol>
<li>如果发送的数据server端没有响应，就会一直重发，直到服务端响应</li>
<li>发送数据前拆包</li>
<li>在1的基础上，每个数据包都有一个offset，最后根据offset组装数据</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://isyuanpeng.github.io/tags/quic/">QUIC</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://isyuanpeng.github.io/posts/other/github-project/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Github Project</span>
  </a>
  <a class="next" href="https://isyuanpeng.github.io/posts/tech/maven%E4%B9%8Bdeploy%E4%BD%BF%E7%94%A8/">
    <span class="title">Next Page »</span>
    <br>
    <span>Maven之Deploy使用</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://isyuanpeng.github.io/">Isyuanpeng</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
